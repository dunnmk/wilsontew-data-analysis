---
title: "CSV Summary Analysis"
output:
  html_document:
    theme: bootstrap
    toc: true
    toc_depth: 3
---
This R Markdown document reads, combines, and summarizes multiple
`_summary.csv` files.
***
## 0. Packages

This section loads the packages used for import, manipulation, and plotting.

- `tidyverse` provides `dplyr`, `readr`, `purrr`, `stringr`, and `ggplot2`.
```{r setup, message=FALSE}
library(tidyverse)

# Ensure rmarkdown can find Pandoc.
# On Windows, Quarto bundles pandoc in: <quarto>/bin/tools/pandoc.exe.
if (!nzchar(Sys.which("pandoc"))) {
  quarto_exe <- Sys.which("quarto")
  if (nzchar(quarto_exe)) {
    quarto_tools <- normalizePath(
      file.path(dirname(quarto_exe), "tools"),
      winslash = "/",
      mustWork = FALSE
    )
    if (dir.exists(quarto_tools)) {
      Sys.setenv(RSTUDIO_PANDOC = quarto_tools)
    }
  }
}
```
***

## 1. Read and combine ALL CSVs

Reads all `_summary.csv` files from `folder` and combines them into a single table `dat`.

- `folder`: directory containing summary CSVs
- `files`: all matching file paths
- `raw_list`: list of per-file data frames
- `dat`: combined data frame
```{r import-csv}
folder <- "C:/Users/dunnmk/Downloads/C_summary"
files  <- list.files(folder, pattern = "_summary\\.csv$", full.names = TRUE)
raw_list <- lapply(files, read_csv)
dat <- bind_rows(raw_list)
str(dat)
dat |> head(10) |> knitr::kable(caption = "Combined CSV preview")

```
***

## 2. Aggregate counts and percentages


Purpose- Calculate percentages from aggregated counts

```{r aggregate-counts}
dat_raw <- dat
summarize_counts_pct <- function(dat){
  dat %>%
    summarise(
      Total_Counts   = sum(count, na.rm = TRUE),
      Cis_Counts     = sum(count[cis_trans == "CIS"], na.rm = TRUE),
      Trans_Counts   = sum(count[cis_trans == "TRANS"], na.rm = TRUE),
      A_to_B_Counts  = sum(count[combo == "A_to_B"], na.rm = TRUE),
      C_to_D_Counts  = sum(count[combo == "C_to_D"], na.rm = TRUE),
      A_to_D_Counts  = sum(count[combo == "A_to_D"], na.rm = TRUE),
      C_to_B_Counts  = sum(count[combo == "C_to_B"], na.rm = TRUE),
      Percent_Cis    = if_else(Total_Counts > 0, 100 * Cis_Counts / Total_Counts, NA_real_),
      Percent_Trans  = if_else(Total_Counts > 0, 100 * Trans_Counts / Total_Counts, NA_real_),
      Percent_A_to_B = if_else(Total_Counts > 0, 100 * A_to_B_Counts / Total_Counts, NA_real_),
      Percent_C_to_D = if_else(Total_Counts > 0, 100 * C_to_D_Counts / Total_Counts, NA_real_),
      Percent_A_to_D = if_else(Total_Counts > 0, 100 * A_to_D_Counts / Total_Counts, NA_real_),
      Percent_C_to_B = if_else(Total_Counts > 0, 100 * C_to_B_Counts / Total_Counts, NA_real_),
      .groups = "drop"
    )
}
dat <- dat %>%
  group_by(batch, time_point, DSB) %>%
  summarize_counts_pct()
str(dat)
```

The table above is now aggregated to batch × time_point × DSB.
***

## 2.5 Batch-level QC plots (counts + composition)

Purpose- Quick sanity-check plots *before* allele-level cis/trans normalization.

```{r batch-qc-plots, message=FALSE, warning=FALSE}
# Aggregate from the ungrouped/raw table (dat_raw)
agg_qc <- dat_raw %>%
  group_by(batch, time_point, DSB) %>%
  summarize_counts_pct() %>%
  ungroup()

# Formatting helpers (avoid extra package dependencies)
comma_label <- function(x) {
  ifelse(is.na(x), NA_character_, formatC(x, format = "f", digits = 0, big.mark = ","))
}

pct_label <- function(x, digits = 1) {
  ifelse(is.na(x), NA_character_, paste0(round(x, digits), "%"))
}

# 1) Total counts by batch
p_total_counts <- ggplot(agg_qc, aes(x = batch, y = Total_Counts, fill = DSB)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.75) +
  geom_text(
    aes(label = comma_label(Total_Counts)),
    position = position_dodge(width = 0.8),
    vjust = -0.25,
    size = 2.7
  ) +
  facet_wrap(~ time_point, scales = "free_y") +
  theme_bw() +
  labs(
    title = "Total counts by batch (faceted by time_point)",
    x = "Batch",
    y = "Total counts",
    fill = "DSB"
  )

print(p_total_counts)

# 2) CIS-only counts by category within each batch
cis_counts_long <- agg_qc %>%
  select(batch, time_point, DSB, Cis_Counts, A_to_B_Counts, C_to_D_Counts) %>%
  pivot_longer(
    cols = -c(batch, time_point, DSB),
    names_to = "Metric",
    values_to = "Counts"
  ) %>%
  mutate(
    Metric = factor(
      Metric,
      levels = c("Cis_Counts", "A_to_B_Counts", "C_to_D_Counts"),
      labels = c("CIS (total)", "A to B (cis)", "C to D (cis)")
    )
  )

p_cis_counts <- ggplot(cis_counts_long, aes(x = batch, y = Counts, fill = Metric)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = comma_label(Counts)),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 2.4
  ) +
  facet_grid(time_point ~ DSB, scales = "free_y") +
  theme_bw() +
  labs(
    title = "CIS counts by category per batch",
    x = "Batch",
    y = "Counts",
    fill = ""
  )

print(p_cis_counts)

# 3) TRANS-only counts by category within each batch
trans_counts_long <- agg_qc %>%
  select(batch, time_point, DSB, Trans_Counts, A_to_D_Counts, C_to_B_Counts) %>%
  pivot_longer(
    cols = -c(batch, time_point, DSB),
    names_to = "Metric",
    values_to = "Counts"
  ) %>%
  mutate(
    Metric = factor(
      Metric,
      levels = c("Trans_Counts", "A_to_D_Counts", "C_to_B_Counts"),
      labels = c("TRANS (total)", "A to D (trans)", "C to B (trans)")
    )
  )

p_trans_counts <- ggplot(trans_counts_long, aes(x = batch, y = Counts, fill = Metric)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = comma_label(Counts)),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 2.4
  ) +
  facet_grid(time_point ~ DSB, scales = "free_y") +
  theme_bw() +
  labs(
    title = "TRANS counts by category per batch",
    x = "Batch",
    y = "Counts",
    fill = ""
  )

print(p_trans_counts)

# 4) Percent CIS within each group (no pooling across groups)
pct_cis_only <- agg_qc %>%
  transmute(
    batch, time_point, DSB,
    Percent = Percent_Cis,
    Label = pct_label(Percent)
  )

p_pct_cis <- ggplot(pct_cis_only, aes(x = batch, y = Percent, fill = DSB)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = Label), vjust = -0.25, size = 2.6) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Percent CIS within each group",
    x = "Batch",
    y = "Percent of group total counts",
    fill = "DSB"
  )

print(p_pct_cis)

# 5) Percent TRANS within each group (no pooling across groups)
pct_trans_only <- agg_qc %>%
  transmute(
    batch, time_point, DSB,
    Percent = Percent_Trans,
    Label = pct_label(Percent)
  )

p_pct_trans <- ggplot(pct_trans_only, aes(x = batch, y = Percent, fill = DSB)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = Label), vjust = -0.25, size = 2.6) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Percent TRANS within each group",
    x = "Batch",
    y = "Percent of group total counts",
    fill = "DSB"
  )

print(p_pct_trans)

# 5b) Share of total CIS/TRANS by batch (within each time_point × DSB)
# This answers the earlier "percent CIS compared to total CIS" request without pooling across time_point/DSB.
pct_cis_share <- agg_qc %>%
  group_by(time_point, DSB) %>%
  mutate(
    Total_Cis_TP = sum(Cis_Counts, na.rm = TRUE),
    Percent = if_else(Total_Cis_TP > 0, 100 * Cis_Counts / Total_Cis_TP, NA_real_),
    Label = pct_label(Percent)
  ) %>%
  ungroup() %>%
  select(batch, time_point, DSB, Percent, Label)

p_pct_cis_share <- ggplot(pct_cis_share, aes(x = batch, y = Percent, fill = DSB)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = Label), vjust = -0.25, size = 2.6) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Share of total CIS counts by batch (within time_point × DSB)",
    x = "Batch",
    y = "% of CIS (within time_point × DSB)",
    fill = "DSB"
  )

print(p_pct_cis_share)

pct_trans_share <- agg_qc %>%
  group_by(time_point, DSB) %>%
  mutate(
    Total_Trans_TP = sum(Trans_Counts, na.rm = TRUE),
    Percent = if_else(Total_Trans_TP > 0, 100 * Trans_Counts / Total_Trans_TP, NA_real_),
    Label = pct_label(Percent)
  ) %>%
  ungroup() %>%
  select(batch, time_point, DSB, Percent, Label)

p_pct_trans_share <- ggplot(pct_trans_share, aes(x = batch, y = Percent, fill = DSB)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = Label), vjust = -0.25, size = 2.6) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Share of total TRANS counts by batch (within time_point × DSB)",
    x = "Batch",
    y = "% of TRANS (within time_point × DSB)",
    fill = "DSB"
  )

print(p_pct_trans_share)

# 6) Within-class combo composition (requested breakdowns)
agg_combo_within <- dat_raw %>%
  group_by(batch, time_point, DSB) %>%
  summarise(
    Cis_Counts   = sum(count[cis_trans == "CIS"], na.rm = TRUE),
    Trans_Counts = sum(count[cis_trans == "TRANS"], na.rm = TRUE),

    Cis_A_to_B_Counts = sum(count[cis_trans == "CIS" & combo == "A_to_B"], na.rm = TRUE),
    Cis_C_to_D_Counts = sum(count[cis_trans == "CIS" & combo == "C_to_D"], na.rm = TRUE),

    Trans_A_to_D_Counts = sum(count[cis_trans == "TRANS" & combo == "A_to_D"], na.rm = TRUE),
    Trans_C_to_B_Counts = sum(count[cis_trans == "TRANS" & combo == "C_to_B"], na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    Percent_A_to_B_in_Cis = if_else(Cis_Counts > 0, 100 * Cis_A_to_B_Counts / Cis_Counts, NA_real_),
    Percent_C_to_D_in_Cis = if_else(Cis_Counts > 0, 100 * Cis_C_to_D_Counts / Cis_Counts, NA_real_),
    Percent_Other_in_Cis  = if_else(Cis_Counts > 0,
                                   100 * pmax(Cis_Counts - Cis_A_to_B_Counts - Cis_C_to_D_Counts, 0) / Cis_Counts,
                                   NA_real_),
    Percent_A_to_D_in_Trans = if_else(Trans_Counts > 0, 100 * Trans_A_to_D_Counts / Trans_Counts, NA_real_),
    Percent_C_to_B_in_Trans = if_else(Trans_Counts > 0, 100 * Trans_C_to_B_Counts / Trans_Counts, NA_real_),
    Percent_Other_in_Trans  = if_else(Trans_Counts > 0,
                                     100 * pmax(Trans_Counts - Trans_A_to_D_Counts - Trans_C_to_B_Counts, 0) / Trans_Counts,
                                     NA_real_)
  )

cis_combo_long <- agg_combo_within %>%
  select(batch, time_point, DSB, Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis, Percent_Other_in_Cis) %>%
  pivot_longer(
    cols = c(Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis, Percent_Other_in_Cis),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_B_in_Cis = "A to B (within CIS)",
      Percent_C_to_D_in_Cis = "C to D (within CIS)",
      Percent_Other_in_Cis = "Other (within CIS)"
    )
  )

p_cis_combo_comp <- ggplot(cis_combo_long, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_grid(time_point ~ DSB) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "CIS composition: % A to B and % C to D (of CIS counts)",
    x = "Batch",
    y = "% of CIS counts",
    fill = ""
  )

print(p_cis_combo_comp)

trans_combo_long <- agg_combo_within %>%
  select(batch, time_point, DSB, Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans, Percent_Other_in_Trans) %>%
  pivot_longer(
    cols = c(Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans, Percent_Other_in_Trans),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_D_in_Trans = "A to D (within TRANS)",
      Percent_C_to_B_in_Trans = "C to B (within TRANS)",
      Percent_Other_in_Trans = "Other (within TRANS)"
    )
  )

p_trans_combo_comp <- ggplot(trans_combo_long, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_grid(time_point ~ DSB) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "TRANS composition: % A to D and % C to B (of TRANS counts)",
    x = "Batch",
    y = "% of TRANS counts",
    fill = ""
  )

print(p_trans_combo_comp)

```

# 3. cis/trans normalization — compute totals and percentages per allele

```{r cis-trans-norm}
my_summarize_cistrans <- function(dat){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Location_Counts   = sum(count[cis_trans == "CIS"], na.rm = TRUE),
      Trans_Location_Counts = sum(count[cis_trans == "TRANS"], na.rm = TRUE),
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis_Location_Counts   = sum(Cis_Location_Counts, na.rm = TRUE),
      Total_Trans_Location_Counts = sum(Trans_Location_Counts, na.rm = TRUE),
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      Percent_Location_in_Cis   = if_else(Total_Cis_Location_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Cis_Location_Counts,
                                         NA_real_),
      Percent_Location_in_Trans = if_else(Total_Trans_Location_Counts > 0,
                                         100 * Trans_Location_Counts / Total_Trans_Location_Counts,
                                         NA_real_)
    )
}

dat_norm <- my_summarize_cistrans(dat_raw)
dat_norm |> head(10) |> knitr::kable(caption = "Data after cis/trans normalization")
```
***
# 4. Allele frequency (CIS + TRANS)

```{r allele-freq}
cis_combos <- c("A_to_B", "C_to_D")
trans_combos <- c("A_to_D", "C_to_B")

# From section 4 onward, we define:
#   CIS   := A_to_B + C_to_D
#   TRANS := A_to_D + C_to_B
# and ignore any other combos so each group has exactly two CIS counts.

my_summarize_cistrans_by_combo <- function(dat, cis_combos, trans_combos){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Location_Counts   = sum(count[combo %in% cis_combos], na.rm = TRUE),
      Trans_Location_Counts = sum(count[combo %in% trans_combos], na.rm = TRUE),
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis_Location_Counts   = sum(Cis_Location_Counts, na.rm = TRUE),
      Total_Trans_Location_Counts = sum(Trans_Location_Counts, na.rm = TRUE),
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      # Group-total counts (restricted to the 4 combos only)
      Total_Group_Counts = Total_Cis_Location_Counts + Total_Trans_Location_Counts,

      # Requested semantics (section 4+):
      #   CIS%  = cis_count / total_count
      #   TRANS% = trans_count / total_count
      # where total_count is the TOTAL within the group (batch × time_point × DSB)
      # and CIS/TRANS are defined by the two combos each.
      # NOTE: These are per-allele *contributions* to the group's total.
      Percent_Cis_of_GroupTotal = if_else(Total_Group_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Group_Counts,
                                         NA_real_),
      Percent_Trans_of_GroupTotal = if_else(Total_Group_Counts > 0,
                                           100 * Trans_Location_Counts / Total_Group_Counts,
                                           NA_real_),

      Percent_Location_in_Cis   = if_else(Total_Cis_Location_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Cis_Location_Counts,
                                         NA_real_),
      Percent_Location_in_Trans = if_else(Total_Trans_Location_Counts > 0,
                                         100 * Trans_Location_Counts / Total_Trans_Location_Counts,
                                         NA_real_)
    )
}

# Filter to only the four combos used downstream
dat_focus <- dat_raw %>%
  filter(combo %in% c(cis_combos, trans_combos))

dat_norm_combo <- my_summarize_cistrans_by_combo(dat_focus, cis_combos, trans_combos)

my_summarize_allelefreq <- function(dat){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Counts    = sum(count[combo %in% cis_combos], na.rm = TRUE),
      Trans_Counts  = sum(count[combo %in% trans_combos], na.rm = TRUE),
      Allele_Total  = Cis_Counts + Trans_Counts,
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis   = sum(Cis_Counts, na.rm = TRUE),
      Total_Trans = sum(Trans_Counts, na.rm = TRUE),
      Total_All   = Total_Cis + Total_Trans,
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      Allele_Frequency = if_else(Total_All > 0, Allele_Total / Total_All, NA_real_)
    )
}

dat_allele_freq <- my_summarize_allelefreq(dat_focus)
str(dat_allele_freq)

```
***
# 5. Fold change calculations (120 / 0)

```{r fold-change}
library(tidyr)

# Small pseudocount to avoid divide-by-zero for rare/absent alleles
eps <- 1e-6

dat_fc_cis <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Cis_of_GroupTotal) %>%
  pivot_wider(names_from = time_point, values_from = Percent_Cis_of_GroupTotal, values_fill = 0) %>%
  mutate(
    FoldChange_Cis_120_vs_0 = (`120` + eps) / (`0` + eps),
    Log2FC_Cis_120_vs_0 = log2(FoldChange_Cis_120_vs_0)
  )

dat_fc_trans <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Trans_of_GroupTotal) %>%
  pivot_wider(names_from = time_point, values_from = Percent_Trans_of_GroupTotal, values_fill = 0) %>%
  mutate(
    FoldChange_Trans_120_vs_0 = (`120` + eps) / (`0` + eps),
    Log2FC_Trans_120_vs_0 = log2(FoldChange_Trans_120_vs_0)
  )

```
***
# 6. Correlation: log2 Fold Change vs Allele Frequency

```{r cor-allelefreq}
library(tidyr)

dat_wide <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, DSB, allele, time_point, Percent_Cis_of_GroupTotal, Percent_Trans_of_GroupTotal) %>%
  pivot_wider(names_from = time_point, values_from = c(Percent_Cis_of_GroupTotal, Percent_Trans_of_GroupTotal), values_fill = 0) %>%
  mutate(
    log2FC_CIS   = log2((Percent_Cis_of_GroupTotal_120 + 1e-6) / (Percent_Cis_of_GroupTotal_0 + 1e-6)),
    log2FC_TRANS = log2((Percent_Trans_of_GroupTotal_120 + 1e-6) / (Percent_Trans_of_GroupTotal_0 + 1e-6))
  )

dat_fc_af <- dat_wide %>%
  inner_join(
    dat_allele_freq %>% filter(time_point == 120) %>% select(batch, DSB, allele, Allele_Frequency),
    by = c("batch", "DSB", "allele")
  ) %>%
  filter(!is.na(Allele_Frequency) & Allele_Frequency > 0)

cor_summary <- dat_fc_af %>%
  group_by(batch, DSB) %>%
  summarise(
    cor_CIS_AF   = ifelse(n() >= 2, cor(log2FC_CIS, Allele_Frequency), NA),
    cor_TRANS_AF = ifelse(n() >= 2, cor(log2FC_TRANS, Allele_Frequency), NA),
    n_obs = n()
  )

knitr::kable(cor_summary, caption = "Correlation: log2FC vs Allele Frequency")

```
***
# 7a. CIS percentage bar plot 

```{r CIS-bar-plot}
# From section 4 onward, CIS% is computed as cis_count / total_count (within an allele)
# using only A_to_B + C_to_D as CIS and A_to_D + C_to_B as TRANS.
df_cis_dist <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Cis_of_GroupTotal)

ggplot(df_cis_dist, aes(x = allele, y = Percent_Cis_of_GroupTotal)) +
  geom_col(width = 0.9, fill = "darkgreen") +
  geom_text(
    aes(label = if_else(is.na(Percent_Cis_of_GroupTotal), NA_character_, paste0(round(Percent_Cis_of_GroupTotal, 1), "%"))),
    vjust = -0.25,
    size = 2.3,
    angle = 90
  ) +
  facet_grid(time_point ~ batch + DSB, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
  labs(
    title = "CIS% contribution by allele (cis_count / total_count; A_to_B + C_to_D; T0 + T120)",
    x = "Allele",
    y = "CIS% of group total"
  )

```
# 7b. TRANS percentage bar plot 

```{r trans-bar-plot}
# From section 4 onward, TRANS is defined strictly as A_to_D + C_to_B.
# TRANS% is trans_count / total_count within each allele.

df_trans_dist <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Trans_of_GroupTotal)

ggplot(df_trans_dist, aes(x = allele, y = Percent_Trans_of_GroupTotal)) +
  geom_col(width = 0.9, fill = "steelblue") +
  geom_text(
    aes(label = if_else(is.na(Percent_Trans_of_GroupTotal), NA_character_, paste0(round(Percent_Trans_of_GroupTotal, 1), "%"))),
    vjust = -0.25,
    size = 2.3,
    angle = 90
  ) +
  facet_grid(time_point ~ batch + DSB, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
  labs(
    title = "TRANS% contribution by allele (trans_count / total_count; A_to_D + C_to_B; T0 + T120)",
    x = "Allele",
    y = "TRANS% of group total"
  )

# Optional: TRANS distribution broken down by combo (A_to_D vs C_to_B)
plot_trans_percent_by_combo <- function(dat, combo_name) {
  df_plot <- dat %>%
    filter(combo == combo_name, time_point %in% c(0, 120)) %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Trans_Counts = sum(count, na.rm = TRUE),
      .groups = "drop"
    ) %>%
    group_by(batch, time_point, DSB) %>%
    mutate(
      Total_Trans = sum(Trans_Counts, na.rm = TRUE),
      Percent_Trans = if_else(Total_Trans > 0, 100 * Trans_Counts / Total_Trans, NA_real_)
    ) %>%
    ungroup()

  if (nrow(df_plot) > 0) {
    ggplot(df_plot, aes(x = allele, y = Percent_Trans)) +
      geom_col(fill = "steelblue", width = 0.9) +
      geom_text(
        aes(label = if_else(is.na(Percent_Trans), NA_character_, paste0(round(Percent_Trans, 1), "%"))),
        vjust = -0.25,
        size = 2.3,
        angle = 90
      ) +
      facet_grid(time_point ~ batch + DSB, scales = "free_x") +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
      labs(
        title = paste("Percent of", combo_name, "counts by allele (within group; T0 + T120)"),
        x = "Allele",
        y = "% within combo (within group)"
      )
  }
}

plot_trans_percent_by_combo(dat_focus, "A_to_D")
plot_trans_percent_by_combo(dat_focus, "C_to_B")

```
***
# 8. Fold Change bar plot 

```{r foldchange-bar-plot}
plot_foldchange_cis <- function(dat_fc_cis) {
  ggplot(dat_fc_cis, aes(x = allele, y = FoldChange_Cis_120_vs_0)) +
    geom_col(width = 0.9, fill = "orange") +
    facet_grid(DSB ~ batch, scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
    labs(title = "Fold change (120/0) in CIS by allele", x = "Allele", y = "Fold change (120/0)")
}

plot_foldchange_trans <- function(dat_fc_trans) {
  ggplot(dat_fc_trans, aes(x = allele, y = FoldChange_Trans_120_vs_0)) +
    geom_col(width = 0.9, fill = "steelblue") +
    facet_grid(DSB ~ batch, scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
    labs(title = "Fold change (120/0) in TRANS by allele", x = "Allele", y = "Fold change (120/0)")
}

plot_allele_frequency <- function(dat_allele_freq) {
  ggplot(dat_allele_freq, aes(x = allele, y = Allele_Frequency)) +
    geom_col(width = 0.9, fill = "purple") +
    facet_grid(time_point ~ batch + DSB, scales = "free_x") +
    theme_bw() +
    theme(axis.text.x = element_text(angle = 90, hjust = 0.5)) +
    labs(title = "Allele Frequency (CIS + TRANS)", x = "Allele", y = "Allele Frequency")
}

# Generate fold change plots
plot_foldchange_cis(dat_fc_cis)
plot_foldchange_trans(dat_fc_trans)
plot_allele_frequency(dat_allele_freq)

# CIS fold change plot
p1 <- ggplot(dat_fc_cis, aes(x = allele, y = FoldChange_Cis_120_vs_0, fill = DSB)) +
  geom_col(width = 0.9, position = "dodge") +
  facet_grid(DSB ~ batch, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
  labs(title = "Fold change (120/0) CIS by allele", x = "Allele", y = "Fold change")

print(p1)

# TRANS fold change plot  
p2 <- ggplot(dat_fc_trans, aes(x = allele, y = FoldChange_Trans_120_vs_0, fill = DSB)) +
  geom_col(width = 0.9, position = "dodge") +
  facet_grid(DSB ~ batch, scales = "free_x") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 8)) +
  labs(title = "Fold change (120/0) TRANS by allele", x = "Allele", y = "Fold change")

print(p2)


```
***
# 9. Correlation scatter plots (log2FC vs Allele Frequency)
```{r cor-allele-log}
use_repel <- requireNamespace("ggrepel", quietly = TRUE)

plot_correlation_cis <- function(dat_fc_af, batch_name, dsb_name) {
  df_plot <- dat_fc_af %>% filter(batch == batch_name, DSB == dsb_name)
  if (nrow(df_plot) >= 2) {
    p <- ggplot(df_plot, aes(x = Allele_Frequency, y = log2FC_CIS, label = allele)) +
      geom_point(size = 3, alpha = 0.8, color = "darkgreen") +
      geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
      geom_smooth(method = "lm", se = FALSE, color = "red") +
      theme_bw() +
      labs(
        title = paste0("Log2FC CIS vs Allele Freq | Batch: ", batch_name, " | DSB: ", dsb_name),
        x = "Allele Frequency", y = "log2FC CIS"
      )

    if (use_repel) {
      p <- p + ggrepel::geom_text_repel(size = 3, max.overlaps = 20)
    } else {
      p <- p + geom_text(size = 3, check_overlap = TRUE, vjust = -0.25)
    }

    p
  }
}

plot_correlation_trans <- function(dat_fc_af, batch_name, dsb_name) {
  df_plot <- dat_fc_af %>% filter(batch == batch_name, DSB == dsb_name)
  if (nrow(df_plot) >= 2) {
    p <- ggplot(df_plot, aes(x = Allele_Frequency, y = log2FC_TRANS, label = allele)) +
      geom_point(size = 3, alpha = 0.8, color = "steelblue") +
      geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
      geom_smooth(method = "lm", se = FALSE, color = "red") +
      theme_bw() +
      labs(
        title = paste0("Log2FC TRANS vs Allele Freq | Batch: ", batch_name, " | DSB: ", dsb_name),
        x = "Allele Frequency", y = "log2FC TRANS"
      )

    if (use_repel) {
      p <- p + ggrepel::geom_text_repel(size = 3, max.overlaps = 20)
    } else {
      p <- p + geom_text(size = 3, check_overlap = TRUE, vjust = -0.25)
    }

    p
  }
}

# Generate plots per batch × DSB (no pooling)
plot_keys <- dat_fc_af %>% distinct(batch, DSB) %>% arrange(batch, DSB)
for (i in seq_len(nrow(plot_keys))) {
  b <- plot_keys$batch[[i]]
  d <- plot_keys$DSB[[i]]
  print(plot_correlation_cis(dat_fc_af, b, d))
  print(plot_correlation_trans(dat_fc_af, b, d))
}
```
