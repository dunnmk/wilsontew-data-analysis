---
title: "3C Summary CSV Aggregation and QC"
output:
  html_document:
    theme: bootstrap
    toc: true
    toc_depth: 3
---
This R Markdown document reads, combines, and summarizes multiple
`_summary.csv` files.
***
## 0. Packages

This section loads the packages used for import, manipulation, and plotting.

- `tidyverse` provides `dplyr`, `readr`, `purrr`, `stringr`, and `ggplot2`.
```{r setup, message=FALSE}
library(tidyverse)

# Make plots larger and labels more legible throughout the report
knitr::opts_chunk$set(
  fig.width = 16,
  fig.height = 8,
  dpi = 200,
  out.width = "100%",
  fig.align = "center"
)

# Ensure rmarkdown can find Pandoc.
# On Windows, Quarto bundles pandoc in: <quarto>/bin/tools/pandoc.exe.
if (!nzchar(Sys.which("pandoc"))) {
  quarto_exe <- Sys.which("quarto")
  if (nzchar(quarto_exe)) {
    quarto_tools <- normalizePath(
      file.path(dirname(quarto_exe), "tools"),
      winslash = "/",
      mustWork = FALSE
    )
    if (dir.exists(quarto_tools)) {
      Sys.setenv(RSTUDIO_PANDOC = quarto_tools)
    }
  }
}
```
***

## 1. Read and combine ALL CSVs

Reads all `_summary.csv` files from `folder` and combines them into a single master table `dat_raw`.

- `folder`: directory containing summary CSVs
- `files`: all matching file paths
- `raw_list`: list of per-file data frames
- `dat_raw`: combined data frame
```{r import-csv}
folder <- "C:\\Users\\dunnmk\\University of Michigan Dropbox\\MED-WILSONTELAB\\wilsontelab box\\Common\\Projects\\Yeast Aim 3\\3C Sequencing Data\\3C_summary"
files  <- list.files(folder, pattern = "_summary\\.csv$", full.names = TRUE)
raw_list <- lapply(files, read_csv)
dat_raw <- bind_rows(raw_list)
dat_raw <- dat_raw %>%
  mutate(batch = factor(batch, levels = sort(unique(batch))))
str(dat_raw)
dat_raw |> head(10) |> knitr::kable(caption = "Preview: combined raw `_summary.csv` rows (first 10)")

```
***

## 2. Aggregate counts and percentages


Purpose- Calculate percentages from aggregated counts

```{r aggregate-counts}
summarize_counts_pct <- function(dat){
  dat %>%
    summarise(
      Total_Counts   = sum(count),
      Cis_Counts     = sum(count[cis_trans == "CIS"]),
      Trans_Counts   = sum(count[cis_trans == "TRANS"]),
      A_to_B_Counts  = sum(count[combo == "A_to_B"]),
      C_to_D_Counts  = sum(count[combo == "C_to_D"]),
      A_to_D_Counts  = sum(count[combo == "A_to_D"]),
      C_to_B_Counts  = sum(count[combo == "C_to_B"]),
      Percent_Cis    = if_else(Total_Counts > 0, 100 * Cis_Counts / Total_Counts, NA_real_),
      Percent_Trans  = if_else(Total_Counts > 0, 100 * Trans_Counts / Total_Counts, NA_real_),
      Percent_A_to_B = if_else(Total_Counts > 0, 100 * A_to_B_Counts / Total_Counts, NA_real_),
      Percent_C_to_D = if_else(Total_Counts > 0, 100 * C_to_D_Counts / Total_Counts, NA_real_),
      Percent_A_to_D = if_else(Total_Counts > 0, 100 * A_to_D_Counts / Total_Counts, NA_real_),
      Percent_C_to_B = if_else(Total_Counts > 0, 100 * C_to_B_Counts / Total_Counts, NA_real_),
      .groups = "drop"
    )
}
dat_agg_counts <- dat_raw %>%
  group_by(batch, time_point, DSB) %>%
  summarize_counts_pct()
str(dat_agg_counts)
dat_agg_counts |> head(10) |> knitr::kable(caption = "Aggregated counts + derived percentages by batch × time_point × DSB (first 10)")
```

The table above is now aggregated to batch × time_point × DSB.
***

## 2.5 Batch-level QC plots (counts + composition)

Purpose- Quick sanity-check plots *before* allele-level cis/trans normalization.

```{r batch-qc-plots, message=FALSE, warning=FALSE}
# Aggregate from the master raw table
agg_qc <- dat_raw %>%
  group_by(batch, time_point, DSB) %>%
  summarize_counts_pct()

# From here on in QC, compute CIS/TRANS using ONLY the 4 combos of interest:
#   CIS   := A_to_B + C_to_D
#   TRANS := A_to_D + C_to_B
# and define percents relative to the total of these 4 combos.
#
# IMPORTANT: we intentionally DO NOT group by `DSB` here.
# In this dataset, `DSB` can include levels like "TRANS", and grouping by it
# will split CIS and TRANS into different facets and produce misleading 100% bars.
agg_qc_combo4 <- dat_raw %>%
  group_by(batch, time_point) %>%
  summarise(
    Total_All = sum(count),
    A_to_B = sum(count[combo == "A_to_B"]),
    C_to_D = sum(count[combo == "C_to_D"]),
    A_to_D = sum(count[combo == "A_to_D"]),
    C_to_B = sum(count[combo == "C_to_B"]),
    .groups = "drop"
  ) %>%
  mutate(
    Cis_Counts = A_to_B + C_to_D,
    Trans_Counts = A_to_D + C_to_B,
    Total_4Combos = Cis_Counts + Trans_Counts,
    Excluded_Counts = pmax(Total_All - Total_4Combos, 0),
    Percent_Cis = if_else(Total_4Combos > 0, 100 * Cis_Counts / Total_4Combos, NA_real_),
    Percent_Trans = if_else(Total_4Combos > 0, 100 * Trans_Counts / Total_4Combos, NA_real_),
    Percent_A_to_B_in_Cis = if_else(Cis_Counts > 0, 100 * A_to_B / Cis_Counts, NA_real_),
    Percent_C_to_D_in_Cis = if_else(Cis_Counts > 0, 100 * C_to_D / Cis_Counts, NA_real_),
    Percent_A_to_D_in_Trans = if_else(Trans_Counts > 0, 100 * A_to_D / Trans_Counts, NA_real_),
    Percent_C_to_B_in_Trans = if_else(Trans_Counts > 0, 100 * C_to_B / Trans_Counts, NA_real_)
  )

# Quick diagnostic table: if Excluded_Counts is large, then the 4-combo definition is omitting real counts.
agg_qc_combo4 %>%
  arrange(time_point, batch) %>%
  transmute(
    batch, time_point,
    Total_All,
    Total_4Combos,
    Excluded_Counts,
    Percent_Cis,
    Percent_Trans
  ) %>%
  head(20) %>%
  knitr::kable(caption = "QC (4-combo definition): totals vs excluded counts, plus CIS%/TRANS% (first 20 rows)")

# Formatting helpers (avoid extra package dependencies)
comma_label <- function(x) {
  ifelse(is.na(x), NA_character_, formatC(x, format = "f", digits = 0, big.mark = ","))
}

pct_label <- function(x, digits = 1) {
  ifelse(is.na(x), NA_character_, paste0(round(x, digits), "%"))
}

# 1) Total counts by batch
p_total_counts <- ggplot(agg_qc, aes(x = batch, y = Total_Counts, fill = DSB)) +
  geom_col(position = position_dodge(width = 0.8), width = 0.75) +
  geom_text(
    aes(label = comma_label(Total_Counts)),
    position = position_dodge(width = 0.8),
    vjust = -0.25,
    size = 2.7
  ) +
  facet_wrap(~ time_point, scales = "free_y") +
  theme_bw() +
  labs(
    title = "Total counts by batch (faceted by time_point)",
    x = "Batch",
    y = "Total counts",
    fill = "DSB"
  )

if (nrow(agg_qc) > 0) {
  print(p_total_counts)
}

# 2) CIS-only counts by category within each batch (4-combo definition)
cis_counts_long <- agg_qc_combo4 %>%
  select(batch, time_point, Cis_Counts, A_to_B, C_to_D) %>%
  pivot_longer(
    cols = -c(batch, time_point),
    names_to = "Metric",
    values_to = "Counts"
  ) %>%
  mutate(
    Metric = factor(
      Metric,
      levels = c("Cis_Counts", "A_to_B", "C_to_D"),
      labels = c("CIS (total)", "A to B (cis)", "C to D (cis)")
    )
  )

p_cis_counts <- ggplot(cis_counts_long, aes(x = batch, y = Counts, fill = Metric)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = comma_label(Counts)),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 2.4
  ) +
  facet_wrap(~ time_point, scales = "free_y") +
  theme_bw() +
  labs(
    title = "CIS counts by category per batch",
    x = "Batch",
    y = "Counts",
    fill = ""
  )

if (nrow(cis_counts_long) > 0) {
  print(p_cis_counts)
}

# 3) TRANS-only counts by category within each batch (4-combo definition)
trans_counts_long <- agg_qc_combo4 %>%
  select(batch, time_point, Trans_Counts, A_to_D, C_to_B) %>%
  pivot_longer(
    cols = -c(batch, time_point),
    names_to = "Metric",
    values_to = "Counts"
  ) %>%
  mutate(
    Metric = factor(
      Metric,
      levels = c("Trans_Counts", "A_to_D", "C_to_B"),
      labels = c("TRANS (total)", "A to D (trans)", "C to B (trans)")
    )
  )

p_trans_counts <- ggplot(trans_counts_long, aes(x = batch, y = Counts, fill = Metric)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = comma_label(Counts)),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 2.4
  ) +
  facet_wrap(~ time_point, scales = "free_y") +
  theme_bw() +
  labs(
    title = "TRANS counts by category per batch",
    x = "Batch",
    y = "Counts",
    fill = ""
  )

if (nrow(trans_counts_long) > 0) {
  print(p_trans_counts)
}

# 4) CIS vs TRANS percent for each batch (single plot; bars side-by-side)
# Percent_Cis/Percent_Trans are computed relative to TOTAL_4Combos.
pct_cis_trans_long <- agg_qc_combo4 %>%
  select(batch, time_point, Percent_Cis, Percent_Trans) %>%
  pivot_longer(
    cols = c(Percent_Cis, Percent_Trans),
    names_to = "Class",
    values_to = "Percent"
  ) %>%
  mutate(
    Class = recode(Class, Percent_Cis = "CIS", Percent_Trans = "TRANS"),
    Label = pct_label(Percent)
  )

p_pct_cis_trans <- ggplot(pct_cis_trans_long, aes(x = batch, y = Percent, fill = Class)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = Label),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 3.2
  ) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 110)) +
  theme_bw() +
  labs(
    title = "QC: CIS vs TRANS percent per batch (within group)",
    x = "Batch",
    y = "% of total counts",
    fill = ""
  )

if (nrow(pct_cis_trans_long) > 0 && any(!is.na(pct_cis_trans_long$Percent))) {
  print(p_pct_cis_trans)
}

# 5b) Percent TRANS per batch at T0 vs T120 (single plot; bars side-by-side)
pct_trans_time_compare <- agg_qc_combo4 %>%
  filter(time_point %in% c(0, 120)) %>%
  transmute(
    batch,
    time_point = factor(time_point, levels = c(0, 120), labels = c("T0", "T120")),
    Percent_Trans,
    Label = pct_label(Percent_Trans)
  )

p_pct_trans_t0_t120 <- ggplot(pct_trans_time_compare, aes(x = batch, y = Percent_Trans, fill = time_point)) +
  geom_col(position = position_dodge(width = 0.85), width = 0.8) +
  geom_text(
    aes(label = Label),
    position = position_dodge(width = 0.85),
    vjust = -0.25,
    size = 3.2
  ) +
  scale_y_continuous(limits = c(0, 110)) +
  theme_bw() +
  labs(
    title = "QC: TRANS% per batch (T0 vs T120)",
    x = "Batch",
    y = "TRANS% of total",
    fill = "Time"
  )

if (nrow(pct_trans_time_compare) > 0 && any(!is.na(pct_trans_time_compare$Percent_Trans))) {
  print(p_pct_trans_t0_t120)
}

# 6) Within-class combo composition (stacked; should sum to 100% within class)
# Use ONLY the two combos per class (A_to_B/C_to_D within CIS; A_to_D/C_to_B within TRANS)
agg_combo_within_2only <- agg_qc_combo4

cis_combo_long <- agg_combo_within_2only %>%
  select(batch, time_point, Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis) %>%
  pivot_longer(
    cols = c(Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_B_in_Cis = "A_to_B (within CIS)",
      Percent_C_to_D_in_Cis = "C_to_D (within CIS)"
    )
  )

p_cis_combo_comp <- ggplot(cis_combo_long, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "QC: Within-CIS composition (A_to_B + C_to_D = 100%)",
    x = "Batch",
    y = "% of CIS",
    fill = ""
  )

if (nrow(cis_combo_long) > 0 && any(!is.na(cis_combo_long$Percent))) {
  print(p_cis_combo_comp)
}

trans_combo_long <- agg_combo_within_2only %>%
  select(batch, time_point, Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans) %>%
  pivot_longer(
    cols = c(Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_D_in_Trans = "A_to_D (within TRANS)",
      Percent_C_to_B_in_Trans = "C_to_B (within TRANS)"
    )
  )

p_trans_combo_comp <- ggplot(trans_combo_long, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "QC: Within-TRANS composition (A_to_D + C_to_B = 100%)",
    x = "Batch",
    y = "% of TRANS",
    fill = ""
  )

if (nrow(trans_combo_long) > 0 && any(!is.na(trans_combo_long$Percent))) {
  print(p_trans_combo_comp)
}

```

# 3. cis/trans normalization — compute totals and percentages per allele

```{r cis-trans-norm}
my_summarize_cistrans <- function(dat){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Location_Counts   = sum(count[cis_trans == "CIS"]),
      Trans_Location_Counts = sum(count[cis_trans == "TRANS"]),
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis_Location_Counts   = sum(Cis_Location_Counts),
      Total_Trans_Location_Counts = sum(Trans_Location_Counts),
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      Percent_Location_in_Cis   = if_else(Total_Cis_Location_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Cis_Location_Counts,
                                         NA_real_),
      Percent_Location_in_Trans = if_else(Total_Trans_Location_Counts > 0,
                                         100 * Trans_Location_Counts / Total_Trans_Location_Counts,
                                         NA_real_)
    )
}

dat_norm <- my_summarize_cistrans(dat_raw)
dat_norm |> head(10) |> knitr::kable(caption = "Preview: allele-level CIS/TRANS counts and within-class percentages (first 10)")
```
***
# 4. Allele frequency (CIS + TRANS)

```{r allele-freq}
cis_combos <- c("A_to_B", "C_to_D")
trans_combos <- c("A_to_D", "C_to_B")

# From section 4 onward, we define:
#   CIS   := A_to_B + C_to_D
#   TRANS := A_to_D + C_to_B
# and ignore any other combos so each group has exactly two CIS counts.

my_summarize_cistrans_by_combo <- function(dat, cis_combos, trans_combos){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Location_Counts   = sum(count[combo %in% cis_combos]),
      Trans_Location_Counts = sum(count[combo %in% trans_combos]),
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis_Location_Counts   = sum(Cis_Location_Counts),
      Total_Trans_Location_Counts = sum(Trans_Location_Counts),
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      # Group-total counts (restricted to the 4 combos only)
      Total_Group_Counts = Total_Cis_Location_Counts + Total_Trans_Location_Counts,

      # Requested semantics (section 4+):
      #   CIS%  = cis_count / total_count
      #   TRANS% = trans_count / total_count
      # where total_count is the TOTAL within the group (batch × time_point × DSB)
      # and CIS/TRANS are defined by the two combos each.
      # NOTE: These are per-allele *contributions* to the group's total.
      Percent_Cis_of_GroupTotal = if_else(Total_Group_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Group_Counts,
                                         NA_real_),
      Percent_Trans_of_GroupTotal = if_else(Total_Group_Counts > 0,
                                           100 * Trans_Location_Counts / Total_Group_Counts,
                                           NA_real_),

      Percent_Location_in_Cis   = if_else(Total_Cis_Location_Counts > 0,
                                         100 * Cis_Location_Counts / Total_Cis_Location_Counts,
                                         NA_real_),
      Percent_Location_in_Trans = if_else(Total_Trans_Location_Counts > 0,
                                         100 * Trans_Location_Counts / Total_Trans_Location_Counts,
                                         NA_real_)
    )
}

# Filter to only the four combos used downstream
dat_focus <- dat_raw %>%
  filter(combo %in% c(cis_combos, trans_combos))

dat_norm_combo <- my_summarize_cistrans_by_combo(dat_focus, cis_combos, trans_combos)

# ---- Group-level summaries using ONLY the four combos (section 4+ semantics) ----
# These are the plots that should behave like:
#   - A_to_B + C_to_D = 100% (within CIS)
#   - A_to_D + C_to_B = 100% (within TRANS)
#   - TRANS% of total is typically lower at T0 than T120 (if biology matches expectation)

dat_group4 <- dat_focus %>%
  # IMPORTANT: do NOT group by DSB here.
  # In this dataset, `DSB` may contain levels like "TRANS" which would split CIS and TRANS
  # across panels and yield misleading 100% bars.
  group_by(batch, time_point) %>%
  summarise(
    A_to_B = sum(count[combo == "A_to_B"]),
    C_to_D = sum(count[combo == "C_to_D"]),
    A_to_D = sum(count[combo == "A_to_D"]),
    C_to_B = sum(count[combo == "C_to_B"]),
    .groups = "drop"
  ) %>%
  mutate(
    Cis_Total = A_to_B + C_to_D,
    Trans_Total = A_to_D + C_to_B,
    Total = Cis_Total + Trans_Total,

    Percent_Cis_of_Total = if_else(Total > 0, 100 * Cis_Total / Total, NA_real_),
    Percent_Trans_of_Total = if_else(Total > 0, 100 * Trans_Total / Total, NA_real_),

    # These should sum to ~100 (within class) when Cis_Total/Trans_Total > 0
    Percent_A_to_B_in_Cis = if_else(Cis_Total > 0, 100 * A_to_B / Cis_Total, NA_real_),
    Percent_C_to_D_in_Cis = if_else(Cis_Total > 0, 100 * C_to_D / Cis_Total, NA_real_),
    Percent_A_to_D_in_Trans = if_else(Trans_Total > 0, 100 * A_to_D / Trans_Total, NA_real_),
    Percent_C_to_B_in_Trans = if_else(Trans_Total > 0, 100 * C_to_B / Trans_Total, NA_real_)
  )

# Share of total CIS/TRANS counts by batch (across ALL batches), separated by time_point.
# This treats the plots as "how much of the total CIS (or TRANS) at this time point comes from each batch".
dat_group4_share <- dat_group4 %>%
  group_by(time_point) %>%
  mutate(
    Total_Cis_AllBatches = sum(Cis_Total),
    Total_Trans_AllBatches = sum(Trans_Total),
    Percent_Cis_Share = if_else(Total_Cis_AllBatches > 0, 100 * Cis_Total / Total_Cis_AllBatches, NA_real_),
    Percent_Trans_Share = if_else(Total_Trans_AllBatches > 0, 100 * Trans_Total / Total_Trans_AllBatches, NA_real_)
  )

p_group4_trans_total <- ggplot(dat_group4_share, aes(x = batch, y = Percent_Trans_Share)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = if_else(is.na(Percent_Trans_Share), NA_character_, paste0(round(Percent_Trans_Share, 1), "%"))),
            vjust = -0.25, size = 3.2) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 110)) +
  theme_bw() +
  labs(
    title = "Share of total TRANS counts by batch (A_to_D + C_to_B only)",
    x = "Batch",
    y = "% of total TRANS (within time point)"
  )

if (nrow(dat_group4_share) > 0 && any(!is.na(dat_group4_share$Percent_Trans_Share))) {
  print(p_group4_trans_total)
}

p_group4_cis_total <- ggplot(dat_group4_share, aes(x = batch, y = Percent_Cis_Share)) +
  geom_col(width = 0.75) +
  geom_text(aes(label = if_else(is.na(Percent_Cis_Share), NA_character_, paste0(round(Percent_Cis_Share, 1), "%"))),
            vjust = -0.25, size = 3.2) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 110)) +
  theme_bw() +
  labs(
    title = "Share of total CIS counts by batch (A_to_B + C_to_D only)",
    x = "Batch",
    y = "% of total CIS (within time point)"
  )

if (nrow(dat_group4_share) > 0 && any(!is.na(dat_group4_share$Percent_Cis_Share))) {
  print(p_group4_cis_total)
}

# Within-CIS composition: A_to_B vs C_to_D (should sum to 100%)
cis_comp_long4 <- dat_group4 %>%
  select(batch, time_point, Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis) %>%
  pivot_longer(
    cols = c(Percent_A_to_B_in_Cis, Percent_C_to_D_in_Cis),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_B_in_Cis = "A_to_B (within CIS)",
      Percent_C_to_D_in_Cis = "C_to_D (within CIS)"
    )
  )

p_cis_comp_2only <- ggplot(cis_comp_long4, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Within-CIS composition (A_to_B + C_to_D = 100%)",
    x = "Batch",
    y = "% of CIS",
    fill = ""
  )

if (nrow(cis_comp_long4) > 0 && any(!is.na(cis_comp_long4$Percent))) {
  print(p_cis_comp_2only)
}

# Within-TRANS composition: A_to_D vs C_to_B (should sum to 100%)
trans_comp_long4 <- dat_group4 %>%
  select(batch, time_point, Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans) %>%
  pivot_longer(
    cols = c(Percent_A_to_D_in_Trans, Percent_C_to_B_in_Trans),
    names_to = "Combo",
    values_to = "Percent"
  ) %>%
  mutate(
    Combo = recode(
      Combo,
      Percent_A_to_D_in_Trans = "A_to_D (within TRANS)",
      Percent_C_to_B_in_Trans = "C_to_B (within TRANS)"
    )
  )

p_trans_comp_2only <- ggplot(trans_comp_long4, aes(x = batch, y = Percent, fill = Combo)) +
  geom_col(width = 0.75) +
  geom_text(
    aes(label = if_else(is.na(Percent) | Percent <= 0, NA_character_, paste0(round(Percent, 1), "%"))),
    position = position_stack(vjust = 0.5),
    size = 2.4
  ) +
  facet_wrap(~ time_point) +
  scale_y_continuous(limits = c(0, 100)) +
  theme_bw() +
  labs(
    title = "Within-TRANS composition (A_to_D + C_to_B = 100%)",
    x = "Batch",
    y = "% of TRANS",
    fill = ""
  )

if (nrow(trans_comp_long4) > 0 && any(!is.na(trans_comp_long4$Percent))) {
  print(p_trans_comp_2only)
}

my_summarize_allelefreq <- function(dat){
  by_allele <- dat %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Cis_Counts    = sum(count[combo %in% cis_combos]),
      Trans_Counts  = sum(count[combo %in% trans_combos]),
      Allele_Total  = Cis_Counts + Trans_Counts,
      .groups = "drop"
    )

  totals <- by_allele %>%
    group_by(batch, time_point, DSB) %>%
    summarise(
      Total_Cis   = sum(Cis_Counts),
      Total_Trans = sum(Trans_Counts),
      Total_All   = Total_Cis + Total_Trans,
      .groups = "drop"
    )

  by_allele %>%
    left_join(totals, by = c("batch", "time_point", "DSB")) %>%
    mutate(
      Allele_Frequency = if_else(Total_All > 0, Allele_Total / Total_All, NA_real_)
    )
}

dat_allele_freq <- my_summarize_allelefreq(dat_focus)
str(dat_allele_freq)

```
***
# 5. Fold change calculations (120 / 0)

```{r fold-change}
library(tidyr)

# Fold change helper.
# We compute FC per allele/location as (T120 / T0) on COUNTS.
# If both numerator and denominator are 0, the fold change is undefined -> NA.
eps <- 1e-6
fc_ratio <- function(num, den, eps = 1e-6) {
  ifelse(is.na(num) | is.na(den), NA_real_,
         ifelse(num == 0 & den == 0, NA_real_, (num + eps) / (den + eps)))
}

dat_fc_cis <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Cis_Location_Counts) %>%
  pivot_wider(names_from = time_point, values_from = Cis_Location_Counts, values_fill = 0) %>%
  mutate(
    FoldChange_Cis_120_vs_0 = fc_ratio(`120`, `0`, eps = eps),
    Log2FC_Cis_120_vs_0 = log2(FoldChange_Cis_120_vs_0)
  )

dat_fc_trans <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Trans_Location_Counts) %>%
  pivot_wider(names_from = time_point, values_from = Trans_Location_Counts, values_fill = 0) %>%
  mutate(
    FoldChange_Trans_120_vs_0 = fc_ratio(`120`, `0`, eps = eps),
    Log2FC_Trans_120_vs_0 = log2(FoldChange_Trans_120_vs_0)
  )

```
***
# 6. Correlation: log2 Fold Change vs Allele Frequency

```{r cor-allelefreq}
library(tidyr)

if (!exists("eps", inherits = TRUE)) eps <- 1e-6
if (!exists("fc_ratio", inherits = TRUE)) {
  fc_ratio <- function(num, den, eps = 1e-6) {
    ifelse(is.na(num) | is.na(den), NA_real_,
           ifelse(num == 0 & den == 0, NA_real_, (num + eps) / (den + eps)))
  }
}

dat_wide <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, DSB, allele, time_point, Cis_Location_Counts, Trans_Location_Counts) %>%
  pivot_wider(names_from = time_point, values_from = c(Cis_Location_Counts, Trans_Location_Counts), values_fill = 0) %>%
  mutate(
    log2FC_CIS   = log2(fc_ratio(Cis_Location_Counts_120, Cis_Location_Counts_0, eps = eps)),
    log2FC_TRANS = log2(fc_ratio(Trans_Location_Counts_120, Trans_Location_Counts_0, eps = eps))
  )

dat_fc_af <- dat_wide %>%
  inner_join(
    dat_allele_freq %>% filter(time_point == 120) %>% select(batch, DSB, allele, Allele_Frequency),
    by = c("batch", "DSB", "allele")
  ) %>%
  filter(!is.na(Allele_Frequency) & Allele_Frequency > 0)

cor_summary <- dat_fc_af %>%
  group_by(batch, DSB) %>%
  summarise(
    cor_CIS_AF   = ifelse(n() >= 2, cor(log2FC_CIS, Allele_Frequency), NA),
    cor_TRANS_AF = ifelse(n() >= 2, cor(log2FC_TRANS, Allele_Frequency), NA),
    n_obs = n(),
    .groups = "drop"
  )

knitr::kable(cor_summary, caption = "Correlation summary: Pearson r between log2FC and allele frequency (by batch × DSB)")

```
***
# 7a. CIS percentage bar plot 

```{r CIS-bar-plot}
# CIS% contribution (within CIS only):
#   for each group (batch × time_point × DSB), we compute each allele's share of TOTAL CIS,
#   using ONLY the CIS combos (A_to_B + C_to_D).
df_cis_dist <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Location_in_Cis)

plot_cis_contrib_by_batch <- function(df_cis_dist) {
  df_cis_dist <- df_cis_dist %>%
    mutate(
      time_point = factor(time_point, levels = c(0, 120), labels = c("T0", "T120")),
      DSB = factor(DSB, levels = c("DSB1", "DSB2", "TRANS"))
    )

  batches <- df_cis_dist %>% distinct(batch) %>% arrange(batch) %>% pull(batch)
  for (b in batches) {
    df_plot <- df_cis_dist %>% filter(batch == b)

    if (nrow(df_plot) == 0 || all(is.na(df_plot$Percent_Location_in_Cis))) next

    p <- ggplot(df_plot, aes(x = allele, y = Percent_Location_in_Cis, fill = DSB)) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(Percent_Location_in_Cis), NA_character_, paste0(round(Percent_Location_in_Cis, 1), "%"))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      facet_wrap(~ time_point, scales = "free_x") +
      scale_y_continuous(limits = c(0, 110)) +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste0("CIS% contribution by allele (within CIS only) | Batch: ", b),
        x = "Allele",
        y = "CIS% of CIS total (within group)",
        fill = "DSB"
      )

    print(p)
  }
}

plot_cis_contrib_by_batch(df_cis_dist)

```
# 7b. TRANS percentage bar plot 

```{r trans-bar-plot}
# TRANS% contribution (within TRANS only):
#   for each group (batch × time_point × DSB), we compute each allele's share of TOTAL TRANS,
#   using ONLY the TRANS combos (A_to_D + C_to_B).

df_trans_dist <- dat_norm_combo %>%
  filter(time_point %in% c(0, 120)) %>%
  select(batch, time_point, DSB, allele, Percent_Location_in_Trans)

plot_trans_contrib_by_batch <- function(df_trans_dist) {
  df_trans_dist <- df_trans_dist %>%
    mutate(
      time_point = factor(time_point, levels = c(0, 120), labels = c("T0", "T120")),
      DSB = factor(DSB, levels = c("DSB1", "DSB2", "TRANS"))
    )

  batches <- df_trans_dist %>% distinct(batch) %>% arrange(batch) %>% pull(batch)
  for (b in batches) {
    df_plot <- df_trans_dist %>% filter(batch == b)

    if (nrow(df_plot) == 0 || all(is.na(df_plot$Percent_Location_in_Trans))) next

    p <- ggplot(df_plot, aes(x = allele, y = Percent_Location_in_Trans, fill = DSB)) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(Percent_Location_in_Trans), NA_character_, paste0(round(Percent_Location_in_Trans, 1), "%"))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      facet_wrap(~ time_point, scales = "free_x") +
      scale_y_continuous(limits = c(0, 110)) +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste0("TRANS% contribution by allele (within TRANS only) | Batch: ", b),
        x = "Allele",
        y = "TRANS% of TRANS total (within group)",
        fill = "DSB"
      )

    print(p)
  }
}

plot_trans_contrib_by_batch(df_trans_dist)

# Optional: TRANS distribution broken down by combo (A_to_D vs C_to_B)
# Requested view: T0 and T120 on the SAME graph with different-colored bars.
plot_trans_percent_by_combo <- function(dat, combo_name) {
  combo_map <- c(
    "A to D" = "A_to_D",
    "A_to_D" = "A_to_D",
    "B to C" = "C_to_B",
    "B_to_C" = "C_to_B",
    "C to B" = "C_to_B",
    "C_to_B" = "C_to_B"
  )
  if (!is.null(combo_map[[combo_name]])) {
    combo_name <- combo_map[[combo_name]]
  }

  df_plot <- dat %>%
    filter(combo == combo_name, time_point %in% c(0, 120)) %>%
    group_by(batch, time_point, DSB, allele) %>%
    summarise(
      Trans_Counts = sum(count),
      .groups = "drop"
    ) %>%
    group_by(batch, time_point, DSB) %>%
    mutate(
      Total_Trans = sum(Trans_Counts),
      Percent_Trans = if_else(Total_Trans > 0, 100 * Trans_Counts / Total_Trans, NA_real_)
    )

  if (nrow(df_plot) == 0 || all(is.na(df_plot$Percent_Trans))) return(NULL)

  ggplot(
      df_plot,
      aes(
        x = allele,
        y = Percent_Trans,
        fill = factor(time_point, levels = c(0, 120), labels = c("T0", "T120"))
      )
    ) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(Percent_Trans), NA_character_, paste0(round(Percent_Trans, 1), "%"))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      facet_grid(batch + DSB ~ ., scales = "free_x") +
      scale_y_continuous(limits = c(0, 110)) +
      theme_bw() +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste("Percent of", combo_name, "counts by allele (within combo; T0 vs T120)"),
        x = "Allele",
        y = "% within combo (within group)",
        fill = "Time"
      )
}

p_trans_ad <- plot_trans_percent_by_combo(dat_focus, "A_to_D")
if (!is.null(p_trans_ad)) print(p_trans_ad)

p_trans_cb <- plot_trans_percent_by_combo(dat_focus, "C_to_B")
if (!is.null(p_trans_cb)) print(p_trans_cb)

```
***
# 8. Fold Change bar plot 

```{r foldchange-bar-plot}
plot_foldchange_cis_by_batch <- function(dat_fc_cis) {
  batches <- dat_fc_cis %>% distinct(batch) %>% arrange(batch) %>% pull(batch)
  for (b in batches) {
    df_plot <- dat_fc_cis %>% filter(batch == b)

    if (nrow(df_plot) == 0 || all(is.na(df_plot$FoldChange_Cis_120_vs_0))) next
    p <- ggplot(df_plot, aes(x = allele, y = FoldChange_Cis_120_vs_0, fill = DSB)) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(FoldChange_Cis_120_vs_0), NA_character_, sprintf("%.3f", FoldChange_Cis_120_vs_0))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
      theme_bw(base_size = 14) +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste0("Fold change (120/0) in CIS counts by allele | Batch: ", b),
        x = "Allele",
        y = "Fold change of CIS counts (120/0)",
        fill = "DSB"
      )
    print(p)
  }
}

plot_foldchange_trans_by_batch <- function(dat_fc_trans) {
  batches <- dat_fc_trans %>% distinct(batch) %>% arrange(batch) %>% pull(batch)
  for (b in batches) {
    df_plot <- dat_fc_trans %>% filter(batch == b)

    if (nrow(df_plot) == 0 || all(is.na(df_plot$FoldChange_Trans_120_vs_0))) next
    p <- ggplot(df_plot, aes(x = allele, y = FoldChange_Trans_120_vs_0, fill = DSB)) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(FoldChange_Trans_120_vs_0), NA_character_, sprintf("%.3f", FoldChange_Trans_120_vs_0))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
      theme_bw(base_size = 14) +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste0("Fold change (120/0) in TRANS counts by allele | Batch: ", b),
        x = "Allele",
        y = "Fold change of TRANS counts (120/0)",
        fill = "DSB"
      )
    print(p)
  }
}

plot_allele_frequency_by_batch <- function(dat_allele_freq) {
  batches <- dat_allele_freq %>% distinct(batch) %>% arrange(batch) %>% pull(batch)
  for (b in batches) {
    df_plot <- dat_allele_freq %>% filter(batch == b)

    if (nrow(df_plot) == 0 || all(is.na(df_plot$Allele_Frequency))) next
    p <- ggplot(df_plot, aes(x = allele, y = Allele_Frequency, fill = DSB)) +
      geom_col(position = position_dodge(width = 0.9), width = 0.85) +
      geom_text(
        aes(label = if_else(is.na(Allele_Frequency), NA_character_, sprintf("%.3f", Allele_Frequency))),
        position = position_dodge(width = 0.9),
        vjust = -0.25,
        size = 3.0,
        angle = 90
      ) +
      scale_y_continuous(expand = expansion(mult = c(0, 0.15))) +
      facet_wrap(~ time_point, scales = "free_x") +
      theme_bw(base_size = 14) +
      theme(axis.text.x = element_text(angle = 90, hjust = 0.5, vjust = 0.5, size = 10)) +
      labs(
        title = paste0("Allele Frequency (CIS + TRANS) | Batch: ", b),
        x = "Allele",
        y = "Allele Frequency",
        fill = "DSB"
      )
    print(p)
  }
}

# Generate updated plots
plot_foldchange_cis_by_batch(dat_fc_cis)
plot_foldchange_trans_by_batch(dat_fc_trans)
plot_allele_frequency_by_batch(dat_allele_freq)


```
***
# 9. Correlation scatter plots (log2FC vs Allele Frequency)
```{r cor-allele-log}
use_repel <- requireNamespace("ggrepel", quietly = TRUE)

plot_correlation_cis <- function(dat_fc_af, batch_name, dsb_name) {
  df_plot <- dat_fc_af %>% filter(batch == batch_name, DSB == dsb_name)
  if (nrow(df_plot) >= 2) {
    p <- ggplot(df_plot, aes(x = Allele_Frequency, y = log2FC_CIS, label = allele)) +
      geom_point(size = 3, alpha = 0.8, color = "darkgreen") +
      geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
      geom_smooth(method = "lm", se = FALSE, color = "red") +
      theme_bw() +
      labs(
        title = paste0("Log2FC CIS vs Allele Freq | Batch: ", batch_name, " | DSB: ", dsb_name),
        x = "Allele Frequency", y = "log2FC CIS"
      )

    if (use_repel) {
      p <- p + ggrepel::geom_text_repel(size = 3, max.overlaps = 20)
    } else {
      p <- p + geom_text(size = 3, check_overlap = TRUE, vjust = -0.25)
    }

    p
  }
}

plot_correlation_trans <- function(dat_fc_af, batch_name, dsb_name) {
  df_plot <- dat_fc_af %>% filter(batch == batch_name, DSB == dsb_name)
  if (nrow(df_plot) >= 2) {
    p <- ggplot(df_plot, aes(x = Allele_Frequency, y = log2FC_TRANS, label = allele)) +
      geom_point(size = 3, alpha = 0.8, color = "steelblue") +
      geom_hline(yintercept = 0, linetype = "dashed", alpha = 0.5) +
      geom_smooth(method = "lm", se = FALSE, color = "red") +
      theme_bw() +
      labs(
        title = paste0("Log2FC TRANS vs Allele Freq | Batch: ", batch_name, " | DSB: ", dsb_name),
        x = "Allele Frequency", y = "log2FC TRANS"
      )

    if (use_repel) {
      p <- p + ggrepel::geom_text_repel(size = 3, max.overlaps = 20)
    } else {
      p <- p + geom_text(size = 3, check_overlap = TRUE, vjust = -0.25)
    }

    p
  }
}

# Generate plots per batch × DSB (no pooling)
plot_keys <- dat_fc_af %>% distinct(batch, DSB) %>% arrange(batch, DSB)
for (i in seq_len(nrow(plot_keys))) {
  b <- plot_keys$batch[[i]]
  d <- plot_keys$DSB[[i]]
  p_cis <- plot_correlation_cis(dat_fc_af, b, d)
  p_trans <- plot_correlation_trans(dat_fc_af, b, d)
  if (!is.null(p_cis)) print(p_cis)
  if (!is.null(p_trans)) print(p_trans)
}
```
